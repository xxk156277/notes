(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{380:function(t,e,v){"use strict";v.r(e);var _=v(45),a=Object(_.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"vue"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[t._v("#")]),t._v(" Vue")]),t._v(" "),v("p",[t._v("参考文章")]),t._v(" "),v("p",[t._v("作者：我是你的超级英雄\n链接：https://juejin.cn/post/6844903918753808398\n来源：掘金")]),t._v(" "),v("p"),v("div",{staticClass:"table-of-contents"},[v("ul",[v("li",[v("a",{attrs:{href:"#_1、mvvm"}},[t._v("1、MVVM")])]),v("li",[v("a",{attrs:{href:"#_2、vue-数据双向绑定"}},[t._v("2、vue 数据双向绑定")])]),v("li",[v("a",{attrs:{href:"#_3、说说你对-spa-单页面的理解-它的优缺点分别是什么"}},[t._v("3、说说你对 SPA 单页面的理解，它的优缺点分别是什么？")])]),v("li",[v("a",{attrs:{href:"#_4、v-show-与-v-if-有什么区别"}},[t._v("4、v-show 与 v-if 有什么区别？")])]),v("li",[v("a",{attrs:{href:"#_5、怎样理解-vue-的单向数据流"}},[t._v("5、怎样理解 Vue 的单向数据流？")])]),v("li",[v("a",{attrs:{href:"#_6、computed-和-watch-的区别和运用的场景"}},[t._v("6、computed 和 watch 的区别和运用的场景？")])]),v("li",[v("a",{attrs:{href:"#_7、vue生命周期"}},[t._v("7、vue生命周期")])]),v("li",[v("a",{attrs:{href:"#_8、你使用过-vuex-吗"}},[t._v("8、你使用过 Vuex 吗？")])]),v("li",[v("a",{attrs:{href:"#_9、vue-router-路由模式有几种"}},[t._v("9、vue-router 路由模式有几种？")])]),v("li",[v("a",{attrs:{href:"#_10、能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗"}},[t._v("10、能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？")])])])]),v("p"),t._v(" "),v("h3",{attrs:{id:"_1、mvvm"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1、mvvm"}},[t._v("#")]),t._v(" 1、MVVM")]),t._v(" "),v("p",[v("code",[t._v("Model–View–ViewModel （MVVM）")]),t._v(" 是一个软件架构设计模式。"),v("code",[t._v("MVVM")]),t._v(" 的出现促进了前端开发与后端业务逻辑的分离，极大地提高了前端开发效率，"),v("code",[t._v("MVVM")]),t._v(" 的核心是"),v("code",[t._v("ViewModel")]),t._v(" 层，它就像是一个中转站（value converter），负责转换 "),v("code",[t._v("Model")]),t._v(" 中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与 "),v("code",[t._v("Model")]),t._v(" 层通过接口请求进行数据交互，起呈上启下作用。"),v("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/8/19/16ca75871ec53fba?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:"MVVM"}})]),t._v(" "),v("p",[t._v("（1）View 层")]),t._v(" "),v("p",[t._v("View 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建 。")]),t._v(" "),v("p",[t._v("（2）Model 层")]),t._v(" "),v("p",[t._v("Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，对于前端来说就是后端提供的 api 接口。")]),t._v(" "),v("p",[t._v("（3）ViewModel 层")]),t._v(" "),v("p",[t._v("ViewModel 是由前端开发人员组织生成和维护的"),v("strong",[t._v("视 h 图数据层")]),t._v("。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以"),v("strong",[t._v("生成符合 View 层使用预期的视图数据模型")]),t._v("。需要注意的是 ViewModel 所封装出来的数据模型包括"),v("strong",[t._v("视图的状态和行为")]),t._v("两部分，而 Model 层的数据模型是只包含状态的，比如页面的这一块展示什么，而页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为（交互），视图状态和行为都封装在了 ViewModel 里。这样的封装使得 ViewModel 可以完整地去描述 View 层。")]),t._v(" "),v("h3",{attrs:{id:"_2、vue-数据双向绑定"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2、vue-数据双向绑定"}},[t._v("#")]),t._v(" 2、vue 数据双向绑定")]),t._v(" "),v("p",[t._v("Vue 主要通过以下 4 个步骤来实现数据双向绑定的：")]),t._v(" "),v("p",[t._v("实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。")]),t._v(" "),v("p",[t._v("实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。")]),t._v(" "),v("p",[t._v("实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。")]),t._v(" "),v("p",[t._v("实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。")]),t._v(" "),v("h3",{attrs:{id:"_3、说说你对-spa-单页面的理解-它的优缺点分别是什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3、说说你对-spa-单页面的理解-它的优缺点分别是什么"}},[t._v("#")]),t._v(" 3、说说你对 SPA 单页面的理解，它的优缺点分别是什么？")]),t._v(" "),v("p",[t._v("SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。")]),t._v(" "),v("p",[v("strong",[t._v("优点：")])]),t._v(" "),v("ul",[v("li",[t._v("用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；")]),t._v(" "),v("li",[t._v("基于上面一点，SPA 相对对服务器压力小；")]),t._v(" "),v("li",[t._v("前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；")])]),t._v(" "),v("p",[v("strong",[t._v("缺点：")])]),t._v(" "),v("ul",[v("li",[t._v("初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；")]),t._v(" "),v("li",[t._v("前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；")])]),t._v(" "),v("h3",{attrs:{id:"_4、v-show-与-v-if-有什么区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4、v-show-与-v-if-有什么区别"}},[t._v("#")]),t._v(" 4、v-show 与 v-if 有什么区别？")]),t._v(" "),v("p",[v("strong",[t._v("v-if")]),t._v(" 是"),v("strong",[t._v("真正")]),t._v("的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是"),v("strong",[t._v("惰性的")]),t._v("：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。")]),t._v(" "),v("p",[v("strong",[t._v("v-show")]),t._v(" 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。")]),t._v(" "),v("p",[t._v("所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。")]),t._v(" "),v("h3",{attrs:{id:"_5、怎样理解-vue-的单向数据流"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5、怎样理解-vue-的单向数据流"}},[t._v("#")]),t._v(" 5、怎样理解 Vue 的单向数据流？")]),t._v(" "),v("p",[t._v("所有的 prop 都使得其父子 prop 之间形成了一个"),v("strong",[t._v("单向下行绑定")]),t._v("：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。")]),t._v(" "),v("p",[t._v("额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。")]),t._v(" "),v("h3",{attrs:{id:"_6、computed-和-watch-的区别和运用的场景"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6、computed-和-watch-的区别和运用的场景"}},[t._v("#")]),t._v(" 6、computed 和 watch 的区别和运用的场景？")]),t._v(" "),v("p",[v("strong",[t._v("computed：")]),t._v(" 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；")]),t._v(" "),v("p",[v("strong",[t._v("watch：")]),t._v(" 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；")]),t._v(" "),v("p",[v("strong",[t._v("运用场景：")])]),t._v(" "),v("ul",[v("li",[t._v("当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；")]),t._v(" "),v("li",[t._v("当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。")])]),t._v(" "),v("h3",{attrs:{id:"_7、vue生命周期"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7、vue生命周期"}},[t._v("#")]),t._v(" 7、vue生命周期")]),t._v(" "),v("p",[t._v("Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -> 渲染、更新 -> 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。")]),t._v(" "),v("p",[v("strong",[t._v("创建阶段")]),t._v("：")]),t._v(" "),v("ol",[v("li",[v("p",[v("code",[t._v("new Vue()")]),t._v("          var  vm = new Vue() 表示开始创建一个Vue的实例对象")])]),t._v(" "),v("li",[v("p",[v("code",[t._v("Init Events & Lifecycle")])]),t._v(" "),v("p",[t._v("表示，刚初始化一个Vue空的实例对象，这时候，这个对象身上，只有默认的一些生命周期函数和默认的事件，其他的东西都未创建。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("beforeCreate")])]),t._v(" "),v("p",[t._v("在beforeCreate生命周期函数执行的时候，data和methods中的数据还没有初始化。")])]),t._v(" "),v("li",[v("p",[v("code",[t._v("Init injections & reactivity")])]),t._v(" "),v("p",[t._v("在created中，data和methods都已经被初始化好了")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("created")])]),t._v(" "),v("p",[t._v("如果要调用methods中的方法，或者操作data中的数据，最早，只能在created中操作")])]),t._v(" "),v("li",[v("p",[v("code",[t._v('Has "el" option?')])]),t._v(" "),v("p",[v("code",[t._v('Has "template" option')])]),t._v(" "),v("p",[t._v("这里表示Vue开始编辑模板，把Vue代码中的那些指令进行执行，最终，在内存中生成一个编译好的最终模板字符串，然后，把这个模板字符串，渲染为内存中的DOM。此时，只是在内存中。渲染好了模板，并没有把模板真正挂载到真正的页面上去；")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("beforeMount")]),t._v("：此函数执行的时候，模板已经在内存中编译好了，但是尚未挂载到页面上去，此时的页面还是旧的。")])]),t._v(" "),v("li",[v("p",[v("code",[t._v('Create vm.$el and replace "el" with it')])]),t._v(" "),v("p",[t._v("这一步，将内存中编译好的模板，真实的替换到浏览器的页面中去")]),t._v(" "),v("p",[t._v("如果通过某些插件操作页面上的DOM节点了，最早要在mounted中进行")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("mounted")])]),t._v(" "),v("p",[t._v("只要执行完了mounted，就表示整个Vue实例已经初始化完毕了；此时组件已经脱离了创建阶段；进入到了运行阶段。")])])]),t._v(" "),v("p",[v("strong",[t._v("运行阶段：")])]),t._v(" "),v("ol",[v("li",[v("p",[v("code",[t._v("Mounted")])])]),t._v(" "),v("li",[v("p",[t._v("When data changes: "),v("strong",[t._v("beforeupdate")])]),t._v(" "),v("p",[t._v("当执行beforeUpdata的时候，页面中的显示的数据，还是旧的，此时data数据是最新的，页面尚未和最新的数据保持同步。")])]),t._v(" "),v("li",[v("p",[v("code",[t._v("Virtual DOM re-render and patch")])]),t._v(" "),v("p",[t._v("这一步执行的是：先根据data中最新的数据，在内存中，重新渲染出一份最新的内存DOM树。")]),t._v(" "),v("p",[t._v("当最新的内存DOM树被更新之后，会把最新的内存DOM树，重新渲染到真实的页面中去，这时候，就完成了数据从data（Model层）->view（视图层）的更新。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("updated")])]),t._v(" "),v("p",[t._v("updated事件执行的时候，页面和data数据已经保持同步了，都是最新的")])])]),t._v(" "),v("p",[v("strong",[t._v("销毁阶段：")])]),t._v(" "),v("ol",[v("li",[v("p",[v("strong",[t._v("beforeDestroy")])]),t._v(" "),v("p",[t._v("当执行beforeDestory钩子函数的时候，Vue实例就已经从运行阶段，进入到了销毁阶段；")]),t._v(" "),v("p",[t._v("当执行beforeDestory的时候，实例身上所有的data和所有的methods，以及过滤器、指令......")]),t._v(" "),v("p",[t._v("都处于可用状态，此时还没有真正执行销毁的过程。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("destroy")])]),t._v(" "),v("p",[t._v("当执行到这里，组件已经被完全销毁了，此时，组件中所有的数据、方法、指令、过滤器...都已经不可用了")])])]),t._v(" "),v("h3",{attrs:{id:"_8、你使用过-vuex-吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8、你使用过-vuex-吗"}},[t._v("#")]),t._v(" 8、你使用过 Vuex 吗？")]),t._v(" "),v("p",[t._v("Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。")]),t._v(" "),v("p",[t._v("（1）Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。")]),t._v(" "),v("p",[t._v("（2）改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。")]),t._v(" "),v("p",[t._v("主要包括以下几个模块：")]),t._v(" "),v("ul",[v("li",[t._v("State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。")]),t._v(" "),v("li",[t._v("Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。")]),t._v(" "),v("li",[t._v("Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。")]),t._v(" "),v("li",[t._v("Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。")]),t._v(" "),v("li",[t._v("Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。")])]),t._v(" "),v("p",[v("strong",[t._v("为啥要有vuex，使用localStorage本地存储不行么？")])]),t._v(" "),v("p",[t._v("Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式，Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 当多个组件拥有同一个状态的时候，vuex能够很好的帮我们处理 可以很好的使用vue开发者工具调试vuex的状态 这些优势是localStorage不能够很好的模拟的")]),t._v(" "),v("p",[v("strong",[t._v("页面刷新后vuex的state数据丢失怎么解决？")])]),t._v(" "),v("p",[t._v("store里的数据是保存在运行内存中的,当页面刷新时，页面会重新加载vue实例，store里面的数据就会被重新赋值初始化。理论上我们是不需要持久存储vuex的值的，因为请求我们会去接口拿数据，进行重新渲染，和第一次进入一样 但是如果非要保存上一次的临时状态，其实可以使用localStorage进行持久化存储，但是这个时候又得去处理和服务端数据同步的问题")]),t._v(" "),v("p",[v("strong",[t._v("vuex会和v-model有冲突")])]),t._v(" "),v("h3",{attrs:{id:"_9、vue-router-路由模式有几种"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_9、vue-router-路由模式有几种"}},[t._v("#")]),t._v(" 9、vue-router 路由模式有几种？")]),t._v(" "),v("p",[t._v("vue-router 有 3 种路由模式：hash、history、abstract，对应的源码如下所示：")]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("switch (mode) {\n  case 'history':\n\tthis.history = new HTML5History(this, options.base)\n\tbreak\n  case 'hash':\n\tthis.history = new HashHistory(this, options.base, this.fallback)\n\tbreak\n  case 'abstract':\n\tthis.history = new AbstractHistory(this, options.base)\n\tbreak\n  default:\n\tif (process.env.NODE_ENV !== 'production') {\n\t  assert(false, `invalid mode: ${mode}`)\n\t}\n}\n复制代码\n")])])]),v("p",[t._v("其中，3 种路由模式的说明如下：")]),t._v(" "),v("ul",[v("li",[t._v("hash:  使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；")]),t._v(" "),v("li",[t._v("history :  依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；")]),t._v(" "),v("li",[t._v("abstract :  支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.")])]),t._v(" "),v("h3",{attrs:{id:"_10、能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_10、能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗"}},[t._v("#")]),t._v(" 10、能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？")]),t._v(" "),v("p",[v("strong",[t._v("（1）hash 模式的实现原理")])]),t._v(" "),v("p",[t._v("早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 '#search'：")]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("https://www.word.com#search\n复制代码\n")])])]),v("p",[t._v("hash  路由模式的实现主要是基于下面几个特性：")]),t._v(" "),v("ul",[v("li",[t._v("URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；")]),t._v(" "),v("li",[t._v("hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；")]),t._v(" "),v("li",[t._v("可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用  JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；")]),t._v(" "),v("li",[t._v("我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。")])]),t._v(" "),v("p",[v("strong",[t._v("（2）history 模式的实现原理")])]),t._v(" "),v("p",[t._v("HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：")]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("window.history.pushState(null, null, path);\nwindow.history.replaceState(null, null, path);\n复制代码\n")])])]),v("p",[t._v("history 路由模式的实现主要基于存在下面几个特性：")]),t._v(" "),v("ul",[v("li",[t._v("pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；")]),t._v(" "),v("li",[t._v("我们可以使用 popstate  事件来监听 url 的变化，从而对页面进行跳转（渲染）；")]),t._v(" "),v("li",[t._v("history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。")])])])}),[],!1,null,null,null);e.default=a.exports}}]);