---
sidebarDepth: 3
---
# 四.Object：基础知识

## 4.1  对象

#### js中有八种数据类型： 

- 7 种原始类型：`string`，`number`，`bigint`，`boolean`，`symbol`，`null` 和 `undefined`

- 对象：

  - 能够储存多个值作为属性，也可以将一个函数作为属性储存。
  - 利用大括号可以创建`{key ：value}`
  - 不同属性之间可以用逗号隔开，这种逗号叫做尾随或者悬挂逗号

  > const声明的对象其内部的属性值是可以更改的

#### 属性值简写

实际开发中，如果我们用已存在的变量当作属性名，可以使用简写

```javascript
let user = {
    name:name,
    age:age,
    sex:'男'
}
//简写：
let user = {
    name,
    age,
    sex:'男'
}
```

#### 属性名限制

属性命名没有限制，可以是任何字符或者symbol

> 注意：一个名为 `__proto__` 的属性。我们不能将它设置为一个非对象的值

#### 属性存在性测试，“in” 操作符

JavaScript 的对象有一个需要注意的特性：能够被访问任何属性。即使属性不存在也不会报错！读取不存在的属性只会得到 `undefined`

通过in操作符可以检查是否有某个属性`"key" in object`

#### "for...in"循环

```javascript
for (key in object) {
  // 对此对象属性中的每个键执行的代码
}
```

> 对象有特别的顺序：整数属性会被进行排序，其他属性则按照创建的顺序显示
>
> “`整数属性`”指的是一个可以在不做任何更改的情况下与一个整数进行相互转换的字符串。

## 4.2   对象引用和复制

与原始类型相比，对象的根本区别之一是对象都是‘通过引用’被存储和复制的

- 原始类型赋值可以得到两个独立的变量
- 对象赋值 被赋值的变量存储的是该对象在内存中的地址，换句话说就是对该对象的“引用"

> **当一个对象变量被复制 —— 引用则被复制，而该对象并没有被复制。**

#### 克隆与合并，Object.assign

- 复制对象需要创建一个新对象，并通过遍历现有属性的结构，在原始类型值的层面，将其复制到新对象，以复制已有对象的结构。

- Object.assign

  ```javascript
  Object.assign(dest, [src1, src2, src3...])
  ```

- 深层克隆：如果某个对象的属性是其他对象的引用，该怎样处理？

  我们应该使用会检查每个 `user[key]` 的值的克隆循环，如果值是一个对象，那么也要复制它的结构。这就叫“深拷贝”。我们可以用递归来实现。或者不自己造轮子，使用现成的实现，例如 JavaScript 库 [lodash](https://lodash.com/) 中的 [_.cloneDeep(obj)](https://lodash.com/docs#cloneDeep)。

## 4.3   垃圾回收

#### 可达性

“可达”值是那些以某种方式可访问或可用的值。它们一定是存储在内存中的。

- 明显不能释放的值被称作根
- 如果一个值可以通过引用或引用链从根访问任何其他值，则认为该值是可达的。

在 JavaScript 引擎中有一个被称作 [垃圾回收器](https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)) 的东西在后台执行。它监控着所有对象的状态，并删除掉那些已经不可达的。

对外引用不重要，只有传入引用才可以使对象可达。

#### 内部算法

垃圾回收的基本算法被称为 “mark-and-sweep”。

定期执行以下“垃圾回收”步骤：

- 垃圾收集器找到所有的根，并“标记”（记住）它们。
- 然后它遍历并“标记”来自它们的所有引用。
- 然后它遍历标记的对象并标记 **它们的** 引用。所有被遍历到的对象都会被记住，以免将来再次遍历到同一个对象。
- ……如此操作，直到所有可达的（从根部）引用都被访问到。
- 没有被标记的对象都会被删除。

## 4.4    对象方法，"this"

作为对象属性的函数被称为 **方法**，在js中，行为action由属性中的函数来表示。

```javascript
let user = {
    name:'join',
}
user.sayhi = function(){
    alert("hello");
}
user.sayHi();
```

#### 方法简写

```javascript
let user = {
  sayHi() { // 与 "sayHi: function()" 一样
    alert("Hello");
  }
};
```

#### 方法中的this

- 为了访问该对象，方法中可以使用`this`关键字，`this` 的值就是在点之前的这个对象，即调用该方法的对象。
- `this`不受限制，`this`的值时在代码运行时计算出来的，它取决于代码上下文：
  - 如果 `obj.f()` 被调用了，则 `this` 在 `f` 函数调用期间是 `obj`。
  - 在没有对象的情况下调用：`this` == `undefined`

#### 箭头函数没有自己的this

箭头函数中引用this，this值取决于外部”正常的“函数。

## 4.5   构造器和操作符"new"

#### 构造函数

构造函数简称构造器，构造器的主要目的 —— 实现可重用的对象创建代码。

1. 它们的命名以大写字母开头。
2. 它们只能由 `"new"` 操作符来执行。

> 从技术上讲，任何函数都可以用作构造器。即：任何函数都可以通过 `new` 来运行，它会执行上面的算法。“首字母大写”是一个共同的约定，以明确表示一个函数将被使用 `new` 来运行。

当一个函数被使用 `new` 操作符执行时，它按照以下步骤：

1. 一个新的空对象被创建并分配给 `this`。

2. 函数体执行。通常它会修改 `this`，为其添加新的属性。

3. 返回 `this` 的值。

   ```javascript
   function User(name) {
     // this = {};（隐式创建）
   
     // 添加属性到 this
     this.name = name;
     this.isAdmin = false;
   
     // return this;（隐式返回）
   }
   ```

#### 构造器模式测试：new.target

在一个函数内部，使用 `new.target` 属性来检查它是否被使用 `new` 进行调用了。

#### 构造器的 return

构造器没有 `return` 语句。它们的任务是将所有必要的东西写入 `this`(隐式返回)，并自动转换为结果。

但是，如果这有一个 `return` 语句，那么规则就简单了：

- 如果 `return` 返回的是一个对象，则返回这个对象，而不是 `this`。
- 如果 `return` 返回的是一个原始类型，则忽略。

> 带有对象的 `return` 返回该对象，在所有其他情况下返回 `this`。

#### 构造器中的方法

我们不仅可以将属性添加到 `this` 中，还可以添加方法。

## 4.6   可选链 "?."

可选链 `?.` 是一种访问嵌套对象属性的安全的方式。即使中间的属性不存在，也不会出现错误。

#### "不存在的属性"的问题

当我们访问嵌套对象的某个属性时，其中间属性出现了不存在的情况。例如user.address.street，当address不存在时，就会报错。我们希望避免出现这种错误，而是接受 `html = null` 作为结果。

> 用if判断不够优雅，嵌套层次很深时就会出现多次重复

#### 可选链

如果可选链 `?.` 前面的部分是 `undefined` 或者 `null`，它会停止运算并返回该部分。

例如 `value?.prop`：

- 如果 `value` 存在，则结果与 `value.prop` 相同，
- 否则（当 `value` 为 `undefined/null` 时）则返回 `undefined`。

> - **不要过度使用可选链**
>
> - `?.` **前的变量必须已声明**
> - **我们可以使用** `?.` **来安全地读取或删除，但不能写入**

如果 `?.` 左边部分不存在，就会立即停止运算（“短路效应”）。所以，如果后面有任何函数调用或者副作用，它们均不会执行。

## 4.7   Symbol类型

对象的`属性键`只能是字符串类型或者 Symbol 类型

#### Symbol

“Symbol” 值表示**唯一**的标识符。

可以使用 `Symbol()` 来创建这种类型的值：

```javascript
// id 是 symbol 的一个实例化对象
let id = Symbol();
```

> **Symbol 不会被自动转换为字符串**，可以使用.toString()方法来转换，或者直接使用symbol.description属性

#### "隐藏"属性

Symbol 允许我们创建对象的“隐藏”属性，代码的任何其他部分都不能意外访问或重写这些属性。

#### 对象字面量中的 Symbol

如果我们要在对象字面量 `{...}` 中使用 Symbol，则需要使用方括号把它括起来。

### Symbol 在 for…in 中会被跳过

Symbol 属性不参与 `for..in` 循环。

#### 全局symbol

有时我们想要名字相同的Symbol具有相同的实体，这里有一个**全局Symbol注册表**。我们可以在其中创建 Symbol 并在稍后访问它们，它可以确保每次访问相同名字的 Symbol 时，返回的都是相同的 Symbol。

- `Symbol.for(key)`:从注册表中读取（不存在则创建）Symbol.

  该调用会检查全局注册表，如果有一个描述为 `key` 的 Symbol，则返回该 Symbol，否则将创建一个新 Symbol（`Symbol(key)`），并通过给定的 `key` 将其存储在注册表中。

-  `Symbol.for(key)` :通过全局 Symbol 返回一个名字。

#### 系统Symbol

JavaScript 内部有很多“系统” Symbol，我们可以使用它们来微调对象的各个方面。

> symbol使用场景：
>
> 1. “隐藏” 对象属性。 如果我们想要向“属于”另一个脚本或者库的对象添加一个属性，我们可以创建一个 Symbol 并使用它作为属性的键。Symbol 属性不会出现在 `for..in` 中，因此它不会意外地被与其他属性一起处理。并且，它不会被直接访问，因为另一个脚本没有我们的 symbol。因此，该属性将受到保护，防止被意外使用或重写。
>
>    因此我们可以使用 Symbol 属性“秘密地”将一些东西隐藏到我们需要的对象中，但其他地方看不到它。
>
> 2. JavaScript 使用了许多系统 Symbol，这些 Symbol 可以作为 `Symbol.*` 访问。我们可以使用它们来改变一些内置行为。例如，在本教程的后面部分，我们将使用 `Symbol.iterator` 来进行 [迭代](https://zh.javascript.info/iterable) 操作，使用 `Symbol.toPrimitive` 来设置 [对象原始值的转换](https://zh.javascript.info/object-toprimitive) 等等。

## 4.8对象—原始值转换(没看懂？？？)

1. 所有的对象在布尔上下文中均为 `true`。所以对于对象只有字符串和数值转换。
2. 数值转换发生在对象相减或应用数学函数时。例如，`Date` 对象可以相减，`date1 - date2` 的结果是两个日期之间的差值。
3. 至于字符串转换 —— 通常发生在我们像 `alert(obj)` 这样输出一个对象和类似的上下文中。

#### 